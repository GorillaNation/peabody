#!/usr/bin/env python

from argparse import ArgumentParser
import sys
import signal
import subprocess
import time
import random
import lockfile
import select
import StringIO
import fcntl
import os

def main():
    global options, cmd

    lock = None
    if options.lockfile:
        lock = lockfile.FileLock(options.lockfile)
        try:
            lock.acquire(0)
        except lockfile.AlreadyLocked:
            # file is locked
            sys.exit(1)
        except lockfile.LockFailed:
            # file couldn't be locked for some reason
            sys.exit(2)

    if options.splay:
        time.sleep(random.randint(0,options.splay))

    try:
        child = subprocess.Popen(cmd,stderr=subprocess.PIPE, stdout=subprocess.PIPE)
        fl = fcntl.fcntl(child.stdout, fcntl.F_GETFL)
        fcntl.fcntl(child.stdout, fcntl.F_SETFL, fl | os.O_NONBLOCK)
        fl = fcntl.fcntl(child.stderr, fcntl.F_GETFL)
        fcntl.fcntl(child.stderr, fcntl.F_SETFL, fl | os.O_NONBLOCK)
    except OSError as e:
        sys.exit("Unable to launch child process: %s (Errno: %i)" % (e.strerror, e.errno))

    if options.timeout:
        def soft_timeout(signum, frame):
            child.terminate()

            if options.hardtimeout:
                def hard_timeout(signum, frame):
                    child.kill()

                signal.signal(signal.SIGALRM, hard_timeout)
                # we've already been waiting softtimeout seconds
                signal.alarm(options.hardtimeout - options.timeout)

        signal.signal(signal.SIGALRM, soft_timeout)
        signal.alarm(options.timeout)

    # this works, but it's REALLY fugly
    fds = {
        child.stderr.fileno(): {
            "label": "STDERR",
            "buf": "",
        },
        child.stdout.fileno(): {
            "label": "STDOUT",
            "buf": "",
        }
    }
    bufs = { "stderr": "", "stdout": "" }
    print "stderr: {0}, stdout: {1}".format(child.stderr.fileno(), child.stdout.fileno())
    while True:
        print "top of loop"
        (reads, writes, rithmatics) = select.select(fds.keys(), [], [])
        for readfd in reads:
            fileno = readfd.fileno()
            fds[fileno]["buf"] += readfd.read(8192)
            print "got something on {0}".format(fileno)
            while True:
                (line, partition, leftover) = fds[fileno]["buf"].partition("\n")
                if partition:
                    print "{0}: {1}".format(fds[fileno]["label"], line)
                    fds[fileno]["buf"] = leftover
                else:
                    break
            if not line:
                print fds[fileno]["buf"]
                print "closing {0}".format(fileno)
                del fds[fileno]








            print "got something on {0}".format(readfd.fileno())
            print "readfd: {0}".format(readfd)
            bytes = readfd.read(8192)
            if readfd.fileno() == child.stderr.fileno():
                bufs["stderr"] += bytes
                # chunk through the lines
                while True:
                    (line, partition, leftover) = bufs["stderr"].partition("\n")
                    if partition:
                        print "STDERR: {0}".format(line)
                        bufs["stderr"] = leftover
                    else: break
                if not line:
                    print bufs["stderr"]
                    del fds["stderr"]
                    del bufs["stderr"]
            elif readfd.fileno() == child.stdout.fileno():
                bufs["stdout"] += bytes
                while True:
                    (line, partition, leftover) = bufs["stdout"].partition("\n")
                    if partition:
                        print "STDOUT: {0}".format(line)
                        bufs["stdout"] = leftover
                    else:
                        break
                if not line:
                    print bufs["stdout"]
                    del fds["stdout"]
                    del bufs["stdout"]
            else:
                print "dunno if I knew {9}".readfd

            print "fds: {0}".format(fds)
        if not fds:
            print "breaking"
            break


    child.wait()

    # shouldn't need to, but for good measure
    if lock:
        lock.release()

    sys.exit(child.returncode)


if __name__ == "__main__":
    # parse command line arguments ... I'd like to figure out how to get it so this does *all* of my arg parsing
    parser = ArgumentParser()
    parser.add_argument("-v", "--verbose", help="set verbose mode", action="store_true")
    parser.add_argument("-t", "--timeout", help="timeout for child process (SIGTERM)", type=int, dest="timeout")
    parser.add_argument("-T", "--hard-timeout", help="hard timeout for child process (SIGKILL)", type=int, dest="hardtimeout")
    parser.add_argument("-s", "--splay", help="sleep randomly for up to SPLAY seconds before running job", type=int, dest="splay")
    parser.add_argument("-l", "--lock-file", help="path to file to lock for concurrency protection", dest="lockfile")
    (options, cmd) = parser.parse_known_args()

    if not cmd:
        print "usage should go here"
        sys.exit(1)

    if (cmd[0] == '--'):
        cmd = cmd[1:]

    main()

